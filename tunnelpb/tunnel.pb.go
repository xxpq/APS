// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.0
// source: tunnelpb/tunnel.proto

package tunnelpb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RelayMessageType defines the type of relay message
type RelayMessageType int32

const (
	RelayMessageType_RELAY_DATA     RelayMessageType = 0
	RelayMessageType_RELAY_CONTROL  RelayMessageType = 1
	RelayMessageType_ROUTE_REQUEST  RelayMessageType = 2
	RelayMessageType_ROUTE_RESPONSE RelayMessageType = 3
	RelayMessageType_HEARTBEAT      RelayMessageType = 4
)

// Enum value maps for RelayMessageType.
var (
	RelayMessageType_name = map[int32]string{
		0: "RELAY_DATA",
		1: "RELAY_CONTROL",
		2: "ROUTE_REQUEST",
		3: "ROUTE_RESPONSE",
		4: "HEARTBEAT",
	}
	RelayMessageType_value = map[string]int32{
		"RELAY_DATA":     0,
		"RELAY_CONTROL":  1,
		"ROUTE_REQUEST":  2,
		"ROUTE_RESPONSE": 3,
		"HEARTBEAT":      4,
	}
)

func (x RelayMessageType) Enum() *RelayMessageType {
	p := new(RelayMessageType)
	*p = x
	return p
}

func (x RelayMessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RelayMessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_tunnelpb_tunnel_proto_enumTypes[0].Descriptor()
}

func (RelayMessageType) Type() protoreflect.EnumType {
	return &file_tunnelpb_tunnel_proto_enumTypes[0]
}

func (x RelayMessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RelayMessageType.Descriptor instead.
func (RelayMessageType) EnumDescriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{0}
}

// ServerToEndpoint is a wrapper for messages sent from the Server (APS) to the Endpoint client.
type ServerToEndpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique ID for the message, used for request/response correlation and cancellations.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ServerToEndpoint_Request
	//	*ServerToEndpoint_Cancel
	//	*ServerToEndpoint_Heartbeat
	//	*ServerToEndpoint_ProxyConnect
	//	*ServerToEndpoint_ProxyData
	//	*ServerToEndpoint_ProxyClose
	Payload       isServerToEndpoint_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerToEndpoint) Reset() {
	*x = ServerToEndpoint{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerToEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerToEndpoint) ProtoMessage() {}

func (x *ServerToEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerToEndpoint.ProtoReflect.Descriptor instead.
func (*ServerToEndpoint) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{0}
}

func (x *ServerToEndpoint) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ServerToEndpoint) GetPayload() isServerToEndpoint_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ServerToEndpoint) GetRequest() *Request {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_Request); ok {
			return x.Request
		}
	}
	return nil
}

func (x *ServerToEndpoint) GetCancel() *Cancel {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_Cancel); ok {
			return x.Cancel
		}
	}
	return nil
}

func (x *ServerToEndpoint) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

func (x *ServerToEndpoint) GetProxyConnect() *ProxyConnect {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_ProxyConnect); ok {
			return x.ProxyConnect
		}
	}
	return nil
}

func (x *ServerToEndpoint) GetProxyData() *ProxyData {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_ProxyData); ok {
			return x.ProxyData
		}
	}
	return nil
}

func (x *ServerToEndpoint) GetProxyClose() *ProxyClose {
	if x != nil {
		if x, ok := x.Payload.(*ServerToEndpoint_ProxyClose); ok {
			return x.ProxyClose
		}
	}
	return nil
}

type isServerToEndpoint_Payload interface {
	isServerToEndpoint_Payload()
}

type ServerToEndpoint_Request struct {
	Request *Request `protobuf:"bytes,2,opt,name=request,proto3,oneof"`
}

type ServerToEndpoint_Cancel struct {
	Cancel *Cancel `protobuf:"bytes,3,opt,name=cancel,proto3,oneof"`
}

type ServerToEndpoint_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,4,opt,name=heartbeat,proto3,oneof"`
}

type ServerToEndpoint_ProxyConnect struct {
	// Proxy connection messages (for reverse proxy mode)
	ProxyConnect *ProxyConnect `protobuf:"bytes,5,opt,name=proxy_connect,json=proxyConnect,proto3,oneof"`
}

type ServerToEndpoint_ProxyData struct {
	ProxyData *ProxyData `protobuf:"bytes,6,opt,name=proxy_data,json=proxyData,proto3,oneof"`
}

type ServerToEndpoint_ProxyClose struct {
	ProxyClose *ProxyClose `protobuf:"bytes,7,opt,name=proxy_close,json=proxyClose,proto3,oneof"`
}

func (*ServerToEndpoint_Request) isServerToEndpoint_Payload() {}

func (*ServerToEndpoint_Cancel) isServerToEndpoint_Payload() {}

func (*ServerToEndpoint_Heartbeat) isServerToEndpoint_Payload() {}

func (*ServerToEndpoint_ProxyConnect) isServerToEndpoint_Payload() {}

func (*ServerToEndpoint_ProxyData) isServerToEndpoint_Payload() {}

func (*ServerToEndpoint_ProxyClose) isServerToEndpoint_Payload() {}

// EndpointToServer is a wrapper for messages sent from the Endpoint client to the Server (APS).
type EndpointToServer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*EndpointToServer_Registration
	//	*EndpointToServer_Response
	//	*EndpointToServer_Heartbeat
	//	*EndpointToServer_ProxyConnectAck
	//	*EndpointToServer_ProxyData
	//	*EndpointToServer_ProxyClose
	Payload       isEndpointToServer_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointToServer) Reset() {
	*x = EndpointToServer{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointToServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointToServer) ProtoMessage() {}

func (x *EndpointToServer) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointToServer.ProtoReflect.Descriptor instead.
func (*EndpointToServer) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{1}
}

func (x *EndpointToServer) GetPayload() isEndpointToServer_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *EndpointToServer) GetRegistration() *RegistrationRequest {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_Registration); ok {
			return x.Registration
		}
	}
	return nil
}

func (x *EndpointToServer) GetResponse() *Response {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_Response); ok {
			return x.Response
		}
	}
	return nil
}

func (x *EndpointToServer) GetHeartbeat() *Heartbeat {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_Heartbeat); ok {
			return x.Heartbeat
		}
	}
	return nil
}

func (x *EndpointToServer) GetProxyConnectAck() *ProxyConnectAck {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_ProxyConnectAck); ok {
			return x.ProxyConnectAck
		}
	}
	return nil
}

func (x *EndpointToServer) GetProxyData() *ProxyData {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_ProxyData); ok {
			return x.ProxyData
		}
	}
	return nil
}

func (x *EndpointToServer) GetProxyClose() *ProxyClose {
	if x != nil {
		if x, ok := x.Payload.(*EndpointToServer_ProxyClose); ok {
			return x.ProxyClose
		}
	}
	return nil
}

type isEndpointToServer_Payload interface {
	isEndpointToServer_Payload()
}

type EndpointToServer_Registration struct {
	Registration *RegistrationRequest `protobuf:"bytes,1,opt,name=registration,proto3,oneof"`
}

type EndpointToServer_Response struct {
	Response *Response `protobuf:"bytes,2,opt,name=response,proto3,oneof"`
}

type EndpointToServer_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,3,opt,name=heartbeat,proto3,oneof"`
}

type EndpointToServer_ProxyConnectAck struct {
	// Proxy connection messages (for reverse proxy mode)
	ProxyConnectAck *ProxyConnectAck `protobuf:"bytes,4,opt,name=proxy_connect_ack,json=proxyConnectAck,proto3,oneof"`
}

type EndpointToServer_ProxyData struct {
	ProxyData *ProxyData `protobuf:"bytes,5,opt,name=proxy_data,json=proxyData,proto3,oneof"`
}

type EndpointToServer_ProxyClose struct {
	ProxyClose *ProxyClose `protobuf:"bytes,6,opt,name=proxy_close,json=proxyClose,proto3,oneof"`
}

func (*EndpointToServer_Registration) isEndpointToServer_Payload() {}

func (*EndpointToServer_Response) isEndpointToServer_Payload() {}

func (*EndpointToServer_Heartbeat) isEndpointToServer_Payload() {}

func (*EndpointToServer_ProxyConnectAck) isEndpointToServer_Payload() {}

func (*EndpointToServer_ProxyData) isEndpointToServer_Payload() {}

func (*EndpointToServer_ProxyClose) isEndpointToServer_Payload() {}

// RegistrationRequest is the very first message sent by the client to identify itself.
type RegistrationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EndpointName  string                 `protobuf:"bytes,1,opt,name=endpoint_name,json=endpointName,proto3" json:"endpoint_name,omitempty"`
	TunnelName    string                 `protobuf:"bytes,2,opt,name=tunnel_name,json=tunnelName,proto3" json:"tunnel_name,omitempty"`
	Password      string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"` // For authentication
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegistrationRequest) Reset() {
	*x = RegistrationRequest{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegistrationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegistrationRequest) ProtoMessage() {}

func (x *RegistrationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegistrationRequest.ProtoReflect.Descriptor instead.
func (*RegistrationRequest) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{2}
}

func (x *RegistrationRequest) GetEndpointName() string {
	if x != nil {
		return x.EndpointName
	}
	return ""
}

func (x *RegistrationRequest) GetTunnelName() string {
	if x != nil {
		return x.TunnelName
	}
	return ""
}

func (x *RegistrationRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

// Request is a raw HTTP request forwarded from the server to the endpoint.
type Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The original URL the request was made to.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// The raw bytes of the HTTP request (e.g., from httputil.DumpRequest).
	// This data will be encrypted by the server before sending.
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Request) Reset() {
	*x = Request{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Request) ProtoMessage() {}

func (x *Request) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Request.ProtoReflect.Descriptor instead.
func (*Request) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{3}
}

func (x *Request) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *Request) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Response is a raw HTTP response sent back from the endpoint to the server.
type Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Correlates with the Request ID from ServerToEndpoint.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Content:
	//
	//	*Response_Data
	//	*Response_Error
	//	*Response_Header
	//	*Response_Chunk
	//	*Response_End
	Content       isResponse_Content `protobuf_oneof:"content"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Response) Reset() {
	*x = Response{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Response) ProtoMessage() {}

func (x *Response) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{4}
}

func (x *Response) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Response) GetContent() isResponse_Content {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *Response) GetData() []byte {
	if x != nil {
		if x, ok := x.Content.(*Response_Data); ok {
			return x.Data
		}
	}
	return nil
}

func (x *Response) GetError() string {
	if x != nil {
		if x, ok := x.Content.(*Response_Error); ok {
			return x.Error
		}
	}
	return ""
}

func (x *Response) GetHeader() *ResponseHeader {
	if x != nil {
		if x, ok := x.Content.(*Response_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *Response) GetChunk() *DataChunk {
	if x != nil {
		if x, ok := x.Content.(*Response_Chunk); ok {
			return x.Chunk
		}
	}
	return nil
}

func (x *Response) GetEnd() *StreamEnd {
	if x != nil {
		if x, ok := x.Content.(*Response_End); ok {
			return x.End
		}
	}
	return nil
}

type isResponse_Content interface {
	isResponse_Content()
}

type Response_Data struct {
	// The raw bytes of the HTTP response (e.g., from httputil.DumpResponse).
	// This data will be encrypted by the client before sending.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

type Response_Error struct {
	Error string `protobuf:"bytes,3,opt,name=error,proto3,oneof"`
}

type Response_Header struct {
	// Streaming response support
	Header *ResponseHeader `protobuf:"bytes,4,opt,name=header,proto3,oneof"`
}

type Response_Chunk struct {
	Chunk *DataChunk `protobuf:"bytes,5,opt,name=chunk,proto3,oneof"`
}

type Response_End struct {
	End *StreamEnd `protobuf:"bytes,6,opt,name=end,proto3,oneof"`
}

func (*Response_Data) isResponse_Content() {}

func (*Response_Error) isResponse_Content() {}

func (*Response_Header) isResponse_Content() {}

func (*Response_Chunk) isResponse_Content() {}

func (*Response_End) isResponse_Content() {}

// Cancel is a message from the server to cancel an in-flight request.
type Cancel struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cancel) Reset() {
	*x = Cancel{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cancel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cancel) ProtoMessage() {}

func (x *Cancel) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cancel.ProtoReflect.Descriptor instead.
func (*Cancel) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{5}
}

// Heartbeat is a message to check if the connection is still alive.
type Heartbeat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Timestamp     int64                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Heartbeat) Reset() {
	*x = Heartbeat{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Heartbeat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Heartbeat) ProtoMessage() {}

func (x *Heartbeat) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Heartbeat.ProtoReflect.Descriptor instead.
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{6}
}

func (x *Heartbeat) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// ProxyConnect is sent by APS to endpoint to request a TCP connection to target
type ProxyConnect struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConnectionId  string                 `protobuf:"bytes,1,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"` // Unique ID for this proxy connection
	Host          string                 `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`                                     // Target hostname
	Port          int32                  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`                                    // Target port
	Tls           bool                   `protobuf:"varint,4,opt,name=tls,proto3" json:"tls,omitempty"`                                      // Whether to use TLS for the connection
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyConnect) Reset() {
	*x = ProxyConnect{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyConnect) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyConnect) ProtoMessage() {}

func (x *ProxyConnect) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyConnect.ProtoReflect.Descriptor instead.
func (*ProxyConnect) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{7}
}

func (x *ProxyConnect) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ProxyConnect) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *ProxyConnect) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *ProxyConnect) GetTls() bool {
	if x != nil {
		return x.Tls
	}
	return false
}

// ProxyConnectAck is sent by endpoint to APS to acknowledge connection result
type ProxyConnectAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConnectionId  string                 `protobuf:"bytes,1,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"` // Correlates with ProxyConnect
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`                              // Whether connection was successful
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`                                   // Error message if failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyConnectAck) Reset() {
	*x = ProxyConnectAck{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyConnectAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyConnectAck) ProtoMessage() {}

func (x *ProxyConnectAck) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyConnectAck.ProtoReflect.Descriptor instead.
func (*ProxyConnectAck) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{8}
}

func (x *ProxyConnectAck) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ProxyConnectAck) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ProxyConnectAck) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// ProxyData is sent in both directions for data transfer
type ProxyData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConnectionId  string                 `protobuf:"bytes,1,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"` // Correlates with ProxyConnect
	Data          []byte                 `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`                                     // Raw TCP data
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyData) Reset() {
	*x = ProxyData{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyData) ProtoMessage() {}

func (x *ProxyData) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyData.ProtoReflect.Descriptor instead.
func (*ProxyData) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{9}
}

func (x *ProxyData) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ProxyData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// ProxyClose is sent to close a proxy connection
type ProxyClose struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ConnectionId  string                 `protobuf:"bytes,1,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"` // Correlates with ProxyConnect
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`                                 // Optional close reason
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxyClose) Reset() {
	*x = ProxyClose{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyClose) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyClose) ProtoMessage() {}

func (x *ProxyClose) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyClose.ProtoReflect.Descriptor instead.
func (*ProxyClose) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{10}
}

func (x *ProxyClose) GetConnectionId() string {
	if x != nil {
		return x.ConnectionId
	}
	return ""
}

func (x *ProxyClose) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// ResponseHeader contains the HTTP response headers
type ResponseHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Header        []byte                 `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"` // Encrypted HTTP response header bytes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResponseHeader) Reset() {
	*x = ResponseHeader{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResponseHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResponseHeader) ProtoMessage() {}

func (x *ResponseHeader) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResponseHeader.ProtoReflect.Descriptor instead.
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{11}
}

func (x *ResponseHeader) GetHeader() []byte {
	if x != nil {
		return x.Header
	}
	return nil
}

// DataChunk contains a chunk of response body data
type DataChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"` // Encrypted chunk of body data
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataChunk) Reset() {
	*x = DataChunk{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataChunk) ProtoMessage() {}

func (x *DataChunk) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataChunk.ProtoReflect.Descriptor instead.
func (*DataChunk) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{12}
}

func (x *DataChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// StreamEnd marks the end of a streaming response
type StreamEnd struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"` // Optional error message if stream ended with error
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamEnd) Reset() {
	*x = StreamEnd{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamEnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamEnd) ProtoMessage() {}

func (x *StreamEnd) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamEnd.ProtoReflect.Descriptor instead.
func (*StreamEnd) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{13}
}

func (x *StreamEnd) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// RelayMessage defines messages for relay communication
type RelayMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          RelayMessageType       `protobuf:"varint,1,opt,name=type,proto3,enum=tunnel.RelayMessageType" json:"type,omitempty"`
	SourceClient  string                 `protobuf:"bytes,2,opt,name=source_client,json=sourceClient,proto3" json:"source_client,omitempty"`
	TargetClient  string                 `protobuf:"bytes,3,opt,name=target_client,json=targetClient,proto3" json:"target_client,omitempty"`
	Data          []byte                 `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelayMessage) Reset() {
	*x = RelayMessage{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelayMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelayMessage) ProtoMessage() {}

func (x *RelayMessage) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelayMessage.ProtoReflect.Descriptor instead.
func (*RelayMessage) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{14}
}

func (x *RelayMessage) GetType() RelayMessageType {
	if x != nil {
		return x.Type
	}
	return RelayMessageType_RELAY_DATA
}

func (x *RelayMessage) GetSourceClient() string {
	if x != nil {
		return x.SourceClient
	}
	return ""
}

func (x *RelayMessage) GetTargetClient() string {
	if x != nil {
		return x.TargetClient
	}
	return ""
}

func (x *RelayMessage) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *RelayMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *RelayMessage) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// RouteInfo contains routing information for relay connections
type RouteInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Source        string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Target        string                 `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Path          []string               `protobuf:"bytes,3,rep,name=path,proto3" json:"path,omitempty"`
	HopCount      int32                  `protobuf:"varint,4,opt,name=hop_count,json=hopCount,proto3" json:"hop_count,omitempty"`
	TotalLatency  int64                  `protobuf:"varint,5,opt,name=total_latency,json=totalLatency,proto3" json:"total_latency,omitempty"`
	Reliability   float64                `protobuf:"fixed64,6,opt,name=reliability,proto3" json:"reliability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteInfo) Reset() {
	*x = RouteInfo{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteInfo) ProtoMessage() {}

func (x *RouteInfo) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteInfo.ProtoReflect.Descriptor instead.
func (*RouteInfo) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{15}
}

func (x *RouteInfo) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *RouteInfo) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *RouteInfo) GetPath() []string {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *RouteInfo) GetHopCount() int32 {
	if x != nil {
		return x.HopCount
	}
	return 0
}

func (x *RouteInfo) GetTotalLatency() int64 {
	if x != nil {
		return x.TotalLatency
	}
	return 0
}

func (x *RouteInfo) GetReliability() float64 {
	if x != nil {
		return x.Reliability
	}
	return 0
}

// RouteRequest requests route calculation
type RouteRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Source          string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Target          string                 `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	AvailableRelays []string               `protobuf:"bytes,3,rep,name=available_relays,json=availableRelays,proto3" json:"available_relays,omitempty"`
	Constraints     *RouteConstraints      `protobuf:"bytes,4,opt,name=constraints,proto3" json:"constraints,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RouteRequest) Reset() {
	*x = RouteRequest{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteRequest) ProtoMessage() {}

func (x *RouteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteRequest.ProtoReflect.Descriptor instead.
func (*RouteRequest) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{16}
}

func (x *RouteRequest) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *RouteRequest) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *RouteRequest) GetAvailableRelays() []string {
	if x != nil {
		return x.AvailableRelays
	}
	return nil
}

func (x *RouteRequest) GetConstraints() *RouteConstraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

// RouteConstraints defines routing constraints
type RouteConstraints struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	MaxHops        int32                  `protobuf:"varint,1,opt,name=max_hops,json=maxHops,proto3" json:"max_hops,omitempty"`
	MaxLatency     int64                  `protobuf:"varint,2,opt,name=max_latency,json=maxLatency,proto3" json:"max_latency,omitempty"`
	MinReliability float64                `protobuf:"fixed64,3,opt,name=min_reliability,json=minReliability,proto3" json:"min_reliability,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RouteConstraints) Reset() {
	*x = RouteConstraints{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteConstraints) ProtoMessage() {}

func (x *RouteConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteConstraints.ProtoReflect.Descriptor instead.
func (*RouteConstraints) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{17}
}

func (x *RouteConstraints) GetMaxHops() int32 {
	if x != nil {
		return x.MaxHops
	}
	return 0
}

func (x *RouteConstraints) GetMaxLatency() int64 {
	if x != nil {
		return x.MaxLatency
	}
	return 0
}

func (x *RouteConstraints) GetMinReliability() float64 {
	if x != nil {
		return x.MinReliability
	}
	return 0
}

// RouteResponse contains calculated routes
type RouteResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Routes         []*RouteInfo           `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	Recommendation string                 `protobuf:"bytes,2,opt,name=recommendation,proto3" json:"recommendation,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RouteResponse) Reset() {
	*x = RouteResponse{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteResponse) ProtoMessage() {}

func (x *RouteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteResponse.ProtoReflect.Descriptor instead.
func (*RouteResponse) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{18}
}

func (x *RouteResponse) GetRoutes() []*RouteInfo {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *RouteResponse) GetRecommendation() string {
	if x != nil {
		return x.Recommendation
	}
	return ""
}

// RouteUpdate updates route information
type RouteUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Endpoint      string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Routes        []*RouteInfo           `protobuf:"bytes,2,rep,name=routes,proto3" json:"routes,omitempty"`
	Timestamp     int64                  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteUpdate) Reset() {
	*x = RouteUpdate{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteUpdate) ProtoMessage() {}

func (x *RouteUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteUpdate.ProtoReflect.Descriptor instead.
func (*RouteUpdate) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{19}
}

func (x *RouteUpdate) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *RouteUpdate) GetRoutes() []*RouteInfo {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *RouteUpdate) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// RouteUpdateResponse confirms route update
type RouteUpdateResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteUpdateResponse) Reset() {
	*x = RouteUpdateResponse{}
	mi := &file_tunnelpb_tunnel_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteUpdateResponse) ProtoMessage() {}

func (x *RouteUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_tunnelpb_tunnel_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteUpdateResponse.ProtoReflect.Descriptor instead.
func (*RouteUpdateResponse) Descriptor() ([]byte, []int) {
	return file_tunnelpb_tunnel_proto_rawDescGZIP(), []int{20}
}

func (x *RouteUpdateResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RouteUpdateResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_tunnelpb_tunnel_proto protoreflect.FileDescriptor

const file_tunnelpb_tunnel_proto_rawDesc = "" +
	"\n" +
	"\x15tunnelpb/tunnel.proto\x12\x06tunnel\"\xdf\x02\n" +
	"\x10ServerToEndpoint\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12+\n" +
	"\arequest\x18\x02 \x01(\v2\x0f.tunnel.RequestH\x00R\arequest\x12(\n" +
	"\x06cancel\x18\x03 \x01(\v2\x0e.tunnel.CancelH\x00R\x06cancel\x121\n" +
	"\theartbeat\x18\x04 \x01(\v2\x11.tunnel.HeartbeatH\x00R\theartbeat\x12;\n" +
	"\rproxy_connect\x18\x05 \x01(\v2\x14.tunnel.ProxyConnectH\x00R\fproxyConnect\x122\n" +
	"\n" +
	"proxy_data\x18\x06 \x01(\v2\x11.tunnel.ProxyDataH\x00R\tproxyData\x125\n" +
	"\vproxy_close\x18\a \x01(\v2\x12.tunnel.ProxyCloseH\x00R\n" +
	"proxyCloseB\t\n" +
	"\apayload\"\xf5\x02\n" +
	"\x10EndpointToServer\x12A\n" +
	"\fregistration\x18\x01 \x01(\v2\x1b.tunnel.RegistrationRequestH\x00R\fregistration\x12.\n" +
	"\bresponse\x18\x02 \x01(\v2\x10.tunnel.ResponseH\x00R\bresponse\x121\n" +
	"\theartbeat\x18\x03 \x01(\v2\x11.tunnel.HeartbeatH\x00R\theartbeat\x12E\n" +
	"\x11proxy_connect_ack\x18\x04 \x01(\v2\x17.tunnel.ProxyConnectAckH\x00R\x0fproxyConnectAck\x122\n" +
	"\n" +
	"proxy_data\x18\x05 \x01(\v2\x11.tunnel.ProxyDataH\x00R\tproxyData\x125\n" +
	"\vproxy_close\x18\x06 \x01(\v2\x12.tunnel.ProxyCloseH\x00R\n" +
	"proxyCloseB\t\n" +
	"\apayload\"w\n" +
	"\x13RegistrationRequest\x12#\n" +
	"\rendpoint_name\x18\x01 \x01(\tR\fendpointName\x12\x1f\n" +
	"\vtunnel_name\x18\x02 \x01(\tR\n" +
	"tunnelName\x12\x1a\n" +
	"\bpassword\x18\x03 \x01(\tR\bpassword\"/\n" +
	"\aRequest\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"\xd7\x01\n" +
	"\bResponse\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x04data\x18\x02 \x01(\fH\x00R\x04data\x12\x16\n" +
	"\x05error\x18\x03 \x01(\tH\x00R\x05error\x120\n" +
	"\x06header\x18\x04 \x01(\v2\x16.tunnel.ResponseHeaderH\x00R\x06header\x12)\n" +
	"\x05chunk\x18\x05 \x01(\v2\x11.tunnel.DataChunkH\x00R\x05chunk\x12%\n" +
	"\x03end\x18\x06 \x01(\v2\x11.tunnel.StreamEndH\x00R\x03endB\t\n" +
	"\acontent\"\b\n" +
	"\x06Cancel\")\n" +
	"\tHeartbeat\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\"m\n" +
	"\fProxyConnect\x12#\n" +
	"\rconnection_id\x18\x01 \x01(\tR\fconnectionId\x12\x12\n" +
	"\x04host\x18\x02 \x01(\tR\x04host\x12\x12\n" +
	"\x04port\x18\x03 \x01(\x05R\x04port\x12\x10\n" +
	"\x03tls\x18\x04 \x01(\bR\x03tls\"f\n" +
	"\x0fProxyConnectAck\x12#\n" +
	"\rconnection_id\x18\x01 \x01(\tR\fconnectionId\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"D\n" +
	"\tProxyData\x12#\n" +
	"\rconnection_id\x18\x01 \x01(\tR\fconnectionId\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"I\n" +
	"\n" +
	"ProxyClose\x12#\n" +
	"\rconnection_id\x18\x01 \x01(\tR\fconnectionId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"(\n" +
	"\x0eResponseHeader\x12\x16\n" +
	"\x06header\x18\x01 \x01(\fR\x06header\"\x1f\n" +
	"\tDataChunk\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\"!\n" +
	"\tStreamEnd\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\"\xb5\x02\n" +
	"\fRelayMessage\x12,\n" +
	"\x04type\x18\x01 \x01(\x0e2\x18.tunnel.RelayMessageTypeR\x04type\x12#\n" +
	"\rsource_client\x18\x02 \x01(\tR\fsourceClient\x12#\n" +
	"\rtarget_client\x18\x03 \x01(\tR\ftargetClient\x12\x12\n" +
	"\x04data\x18\x04 \x01(\fR\x04data\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12>\n" +
	"\bmetadata\x18\x06 \x03(\v2\".tunnel.RelayMessage.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb3\x01\n" +
	"\tRouteInfo\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12\x12\n" +
	"\x04path\x18\x03 \x03(\tR\x04path\x12\x1b\n" +
	"\thop_count\x18\x04 \x01(\x05R\bhopCount\x12#\n" +
	"\rtotal_latency\x18\x05 \x01(\x03R\ftotalLatency\x12 \n" +
	"\vreliability\x18\x06 \x01(\x01R\vreliability\"\xa5\x01\n" +
	"\fRouteRequest\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12)\n" +
	"\x10available_relays\x18\x03 \x03(\tR\x0favailableRelays\x12:\n" +
	"\vconstraints\x18\x04 \x01(\v2\x18.tunnel.RouteConstraintsR\vconstraints\"w\n" +
	"\x10RouteConstraints\x12\x19\n" +
	"\bmax_hops\x18\x01 \x01(\x05R\amaxHops\x12\x1f\n" +
	"\vmax_latency\x18\x02 \x01(\x03R\n" +
	"maxLatency\x12'\n" +
	"\x0fmin_reliability\x18\x03 \x01(\x01R\x0eminReliability\"b\n" +
	"\rRouteResponse\x12)\n" +
	"\x06routes\x18\x01 \x03(\v2\x11.tunnel.RouteInfoR\x06routes\x12&\n" +
	"\x0erecommendation\x18\x02 \x01(\tR\x0erecommendation\"r\n" +
	"\vRouteUpdate\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12)\n" +
	"\x06routes\x18\x02 \x03(\v2\x11.tunnel.RouteInfoR\x06routes\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp\"I\n" +
	"\x13RouteUpdateResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage*k\n" +
	"\x10RelayMessageType\x12\x0e\n" +
	"\n" +
	"RELAY_DATA\x10\x00\x12\x11\n" +
	"\rRELAY_CONTROL\x10\x01\x12\x11\n" +
	"\rROUTE_REQUEST\x10\x02\x12\x12\n" +
	"\x0eROUTE_RESPONSE\x10\x03\x12\r\n" +
	"\tHEARTBEAT\x10\x042T\n" +
	"\rTunnelService\x12C\n" +
	"\tEstablish\x12\x18.tunnel.EndpointToServer\x1a\x18.tunnel.ServerToEndpoint(\x010\x012P\n" +
	"\fRelayService\x12@\n" +
	"\x0eEstablishRelay\x12\x14.tunnel.RelayMessage\x1a\x14.tunnel.RelayMessage(\x010\x012\x95\x01\n" +
	"\x0eRoutingService\x12>\n" +
	"\x0fCalculateRoutes\x12\x14.tunnel.RouteRequest\x1a\x15.tunnel.RouteResponse\x12C\n" +
	"\x0fUpdateRouteInfo\x12\x13.tunnel.RouteUpdate\x1a\x1b.tunnel.RouteUpdateResponseB\fZ\n" +
	"./tunnelpbb\x06proto3"

var (
	file_tunnelpb_tunnel_proto_rawDescOnce sync.Once
	file_tunnelpb_tunnel_proto_rawDescData []byte
)

func file_tunnelpb_tunnel_proto_rawDescGZIP() []byte {
	file_tunnelpb_tunnel_proto_rawDescOnce.Do(func() {
		file_tunnelpb_tunnel_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tunnelpb_tunnel_proto_rawDesc), len(file_tunnelpb_tunnel_proto_rawDesc)))
	})
	return file_tunnelpb_tunnel_proto_rawDescData
}

var file_tunnelpb_tunnel_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_tunnelpb_tunnel_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_tunnelpb_tunnel_proto_goTypes = []any{
	(RelayMessageType)(0),       // 0: tunnel.RelayMessageType
	(*ServerToEndpoint)(nil),    // 1: tunnel.ServerToEndpoint
	(*EndpointToServer)(nil),    // 2: tunnel.EndpointToServer
	(*RegistrationRequest)(nil), // 3: tunnel.RegistrationRequest
	(*Request)(nil),             // 4: tunnel.Request
	(*Response)(nil),            // 5: tunnel.Response
	(*Cancel)(nil),              // 6: tunnel.Cancel
	(*Heartbeat)(nil),           // 7: tunnel.Heartbeat
	(*ProxyConnect)(nil),        // 8: tunnel.ProxyConnect
	(*ProxyConnectAck)(nil),     // 9: tunnel.ProxyConnectAck
	(*ProxyData)(nil),           // 10: tunnel.ProxyData
	(*ProxyClose)(nil),          // 11: tunnel.ProxyClose
	(*ResponseHeader)(nil),      // 12: tunnel.ResponseHeader
	(*DataChunk)(nil),           // 13: tunnel.DataChunk
	(*StreamEnd)(nil),           // 14: tunnel.StreamEnd
	(*RelayMessage)(nil),        // 15: tunnel.RelayMessage
	(*RouteInfo)(nil),           // 16: tunnel.RouteInfo
	(*RouteRequest)(nil),        // 17: tunnel.RouteRequest
	(*RouteConstraints)(nil),    // 18: tunnel.RouteConstraints
	(*RouteResponse)(nil),       // 19: tunnel.RouteResponse
	(*RouteUpdate)(nil),         // 20: tunnel.RouteUpdate
	(*RouteUpdateResponse)(nil), // 21: tunnel.RouteUpdateResponse
	nil,                         // 22: tunnel.RelayMessage.MetadataEntry
}
var file_tunnelpb_tunnel_proto_depIdxs = []int32{
	4,  // 0: tunnel.ServerToEndpoint.request:type_name -> tunnel.Request
	6,  // 1: tunnel.ServerToEndpoint.cancel:type_name -> tunnel.Cancel
	7,  // 2: tunnel.ServerToEndpoint.heartbeat:type_name -> tunnel.Heartbeat
	8,  // 3: tunnel.ServerToEndpoint.proxy_connect:type_name -> tunnel.ProxyConnect
	10, // 4: tunnel.ServerToEndpoint.proxy_data:type_name -> tunnel.ProxyData
	11, // 5: tunnel.ServerToEndpoint.proxy_close:type_name -> tunnel.ProxyClose
	3,  // 6: tunnel.EndpointToServer.registration:type_name -> tunnel.RegistrationRequest
	5,  // 7: tunnel.EndpointToServer.response:type_name -> tunnel.Response
	7,  // 8: tunnel.EndpointToServer.heartbeat:type_name -> tunnel.Heartbeat
	9,  // 9: tunnel.EndpointToServer.proxy_connect_ack:type_name -> tunnel.ProxyConnectAck
	10, // 10: tunnel.EndpointToServer.proxy_data:type_name -> tunnel.ProxyData
	11, // 11: tunnel.EndpointToServer.proxy_close:type_name -> tunnel.ProxyClose
	12, // 12: tunnel.Response.header:type_name -> tunnel.ResponseHeader
	13, // 13: tunnel.Response.chunk:type_name -> tunnel.DataChunk
	14, // 14: tunnel.Response.end:type_name -> tunnel.StreamEnd
	0,  // 15: tunnel.RelayMessage.type:type_name -> tunnel.RelayMessageType
	22, // 16: tunnel.RelayMessage.metadata:type_name -> tunnel.RelayMessage.MetadataEntry
	18, // 17: tunnel.RouteRequest.constraints:type_name -> tunnel.RouteConstraints
	16, // 18: tunnel.RouteResponse.routes:type_name -> tunnel.RouteInfo
	16, // 19: tunnel.RouteUpdate.routes:type_name -> tunnel.RouteInfo
	2,  // 20: tunnel.TunnelService.Establish:input_type -> tunnel.EndpointToServer
	15, // 21: tunnel.RelayService.EstablishRelay:input_type -> tunnel.RelayMessage
	17, // 22: tunnel.RoutingService.CalculateRoutes:input_type -> tunnel.RouteRequest
	20, // 23: tunnel.RoutingService.UpdateRouteInfo:input_type -> tunnel.RouteUpdate
	1,  // 24: tunnel.TunnelService.Establish:output_type -> tunnel.ServerToEndpoint
	15, // 25: tunnel.RelayService.EstablishRelay:output_type -> tunnel.RelayMessage
	19, // 26: tunnel.RoutingService.CalculateRoutes:output_type -> tunnel.RouteResponse
	21, // 27: tunnel.RoutingService.UpdateRouteInfo:output_type -> tunnel.RouteUpdateResponse
	24, // [24:28] is the sub-list for method output_type
	20, // [20:24] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_tunnelpb_tunnel_proto_init() }
func file_tunnelpb_tunnel_proto_init() {
	if File_tunnelpb_tunnel_proto != nil {
		return
	}
	file_tunnelpb_tunnel_proto_msgTypes[0].OneofWrappers = []any{
		(*ServerToEndpoint_Request)(nil),
		(*ServerToEndpoint_Cancel)(nil),
		(*ServerToEndpoint_Heartbeat)(nil),
		(*ServerToEndpoint_ProxyConnect)(nil),
		(*ServerToEndpoint_ProxyData)(nil),
		(*ServerToEndpoint_ProxyClose)(nil),
	}
	file_tunnelpb_tunnel_proto_msgTypes[1].OneofWrappers = []any{
		(*EndpointToServer_Registration)(nil),
		(*EndpointToServer_Response)(nil),
		(*EndpointToServer_Heartbeat)(nil),
		(*EndpointToServer_ProxyConnectAck)(nil),
		(*EndpointToServer_ProxyData)(nil),
		(*EndpointToServer_ProxyClose)(nil),
	}
	file_tunnelpb_tunnel_proto_msgTypes[4].OneofWrappers = []any{
		(*Response_Data)(nil),
		(*Response_Error)(nil),
		(*Response_Header)(nil),
		(*Response_Chunk)(nil),
		(*Response_End)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tunnelpb_tunnel_proto_rawDesc), len(file_tunnelpb_tunnel_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   3,
		},
		GoTypes:           file_tunnelpb_tunnel_proto_goTypes,
		DependencyIndexes: file_tunnelpb_tunnel_proto_depIdxs,
		EnumInfos:         file_tunnelpb_tunnel_proto_enumTypes,
		MessageInfos:      file_tunnelpb_tunnel_proto_msgTypes,
	}.Build()
	File_tunnelpb_tunnel_proto = out.File
	file_tunnelpb_tunnel_proto_goTypes = nil
	file_tunnelpb_tunnel_proto_depIdxs = nil
}
